#!/usr/bin/env node
// scripts/setup-secrets-all-repos.ts
// Master setup script for configuring encryption, gitignore, and secrets sync
// across all InfinityXOneSystems repositories

import * as fs from "fs";
import * as path from "path";
import * as crypto from "crypto";

const REPOS_ROOT = process.env.REPOS_ROOT || path.join(process.env.HOME || process.env.USERPROFILE || "~", "Documents/InfinityXOneSystems");
const REPOS = ["foundation", "frontend", "backend", "ai-orchestrator"];

interface SecretConfig {
  repoName: string;
  hasNodeProject: boolean;
  hasPythonProject: boolean;
  hasGoogleCloud: boolean;
  hasDocker: boolean;
}

interface SetupResult {
  repo: string;
  status: "success" | "failed";
  message: string;
  secretsCount?: number;
}

console.log("ðŸ” Infinity X One Systems - Master Secrets Setup");
console.log("================================================\n");

/**
 * Generate cryptographically secure encryption key
 */
function generateEncryptionKey(length = 32): string {
  return crypto.randomBytes(length).toString("base64");
}

/**
 * Detect project type and required secrets
 */
function detectProjectConfig(repoPath: string): SecretConfig {
  return {
    repoName: path.basename(repoPath),
    hasNodeProject: fs.existsSync(path.join(repoPath, "package.json")),
    hasPythonProject: fs.existsSync(path.join(repoPath, "requirements.txt")) || fs.existsSync(path.join(repoPath, "Pipfile")),
    hasGoogleCloud: fs.existsSync(path.join(repoPath, "src")) && fs.existsSync(path.join(repoPath, "config")),
    hasDocker: fs.existsSync(path.join(repoPath, "Dockerfile")) || fs.existsSync(path.join(repoPath, "docker-compose.yml")),
  };
}

/**
 * Create comprehensive .gitignore for repository type
 */
function createGitignore(repoPath: string, config: SecretConfig): boolean {
  const gitignorePath = path.join(repoPath, ".gitignore");
  
  let content = `# Auto-generated by master secrets setup script
# ============================================================
# DO NOT MODIFY - Use setup-secrets-all-repos.ts to regenerate
# ============================================================

`;

  // Base ignores
  content += `# Environment & Secrets (NEVER COMMIT)
.env
.env.local
.env.*.local
.env.production.local
.env.development.local
.env.test.local
*.env
*.key
*.pem
*.p12
*.token
secrets.json
credentials.json
google-service-account.json

`;

  // Node.js ignores
  if (config.hasNodeProject) {
    content += `# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json
yarn.lock
pnpm-lock.yaml
.npm
.eslintcache

`;
  }

  // Python ignores
  if (config.hasPythonProject) {
    content += `# Python
venv/
env/
ENV/
.venv
__pycache__/
*.py[cod]
*.egg-info/
dist/
build/
*.egg
.Python

`;
  }

  // Build output
  content += `# Build & Compilation
/dist/
/build/
/out/
/.next/
/.vercel/
/.output/
coverage/
.tsbuildinfo

# IDE
.vscode/
.idea/
*.code-workspace
.DS_Store
Thumbs.db

# OS & Temp
*.tmp
*.bak
*.log*
.cache/

`;

  try {
    fs.writeFileSync(gitignorePath, content);
    return true;
  } catch (error: unknown) {
    console.debug(`Failed to write gitignore: ${error instanceof Error ? error.message : "Unknown error"}`);
    return false;
  }
}

/**
 * Create .env.local template for repository
 */
function createEnvLocalTemplate(repoPath: string, config: SecretConfig): boolean {
  const envPath = path.join(repoPath, ".env.local");
  
  // Skip if already exists
  if (fs.existsSync(envPath)) {
    return true;
  }

  let content = `# Local environment variables - NEVER COMMIT
# Generated by master secrets setup - ${new Date().toISOString()}
#
# ============================================================
# REQUIRED: ENCRYPTION & MOBILE ACCESS
# ============================================================
ENCRYPTION_KEY=${generateEncryptionKey()}
ADMIN_KEY=${generateEncryptionKey()}

`;

  // Node.js specific
  if (config.hasNodeProject) {
    content += `# ============================================================
# NODE.JS CONFIGURATION
# ============================================================
PORT=3000
NODE_ENV=development
JWT_SECRET=${crypto.randomBytes(32).toString("hex")}

`;
  }

  // Google Cloud
  if (config.hasGoogleCloud) {
    content += `# ============================================================
# GOOGLE CLOUD CONFIGURATION
# ============================================================
GOOGLE_CLOUD_PROJECT_ID=<your-project-id>
GOOGLE_CLIENT_ID=<your-client-id>.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=GOCSPX-xxxxxxxxxxxxxxxxxxxxx
GOOGLE_SERVICE_ACCOUNT_KEY_PATH=./config/google-service-account.json

`;
  }

  // GitHub secrets
  content += `# ============================================================
# GITHUB CONFIGURATION
# ============================================================
GITHUB_TOKEN=your-github-token-here
GITHUB_REPO=InfinityXOneSystems/${config.repoName}

`;

  // API Keys section
  content += `# ============================================================
# API KEYS (Paste your keys here)
# ============================================================
GROQ_API_KEY=
ANTHROPIC_API_KEY=
OPENAI_API_KEY=

`;

  try {
    fs.writeFileSync(envPath, content);
    return true;
  } catch (error: unknown) {
    console.debug(`Failed to write .env.local: ${error instanceof Error ? error.message : "Unknown error"}`);
    return false;
  }
}

/**
 * Create secrets manifest template
 */
function createSecretsManifestTemplate(repoPath: string): boolean {
  const manifestPath = path.join(repoPath, "secrets-manifest.json");

  const manifest = {
    version: "1.0.0",
    generatedAt: new Date().toISOString(),
    repository: path.basename(repoPath),
    secrets: {
      encryption: {
        ENCRYPTION_KEY: "AES-256-CBC encryption key",
        ADMIN_KEY: "Admin key for token generation",
      },
      github: {
        GITHUB_TOKEN: "GitHub Personal Access Token",
        GITHUB_REPO: "GitHub repository (owner/repo)",
      },
      google: {
        GOOGLE_CLOUD_PROJECT_ID: "Google Cloud project ID",
        GOOGLE_CLIENT_ID: "Google OAuth client ID",
        GOOGLE_CLIENT_SECRET: "Google OAuth client secret",
      },
      apis: {
        GROQ_API_KEY: "Groq API key",
        ANTHROPIC_API_KEY: "Anthropic/Claude API key",
        OPENAI_API_KEY: "OpenAI API key",
      },
    },
    syncStatus: {
      lastSync: new Date().toISOString(),
      synced: false,
      githubSecretsCount: 0,
    },
  };

  try {
    fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
    return true;
  } catch (error: unknown) {
    console.debug(`Failed to write manifest: ${error instanceof Error ? error.message : "Unknown error"}`);
    return false;
  }
}

/**
 * Process single repository
 */
function setupRepository(repoPath: string): SetupResult {
  if (!fs.existsSync(repoPath)) {
    return {
      repo: path.basename(repoPath),
      status: "failed",
      message: `Repository not found: ${repoPath}`,
    };
  }

  const config = detectProjectConfig(repoPath);
  const results: string[] = [];

  // Create .gitignore
  if (createGitignore(repoPath, config)) {
    results.push("âœ… .gitignore created");
  } else {
    results.push("âš ï¸  .gitignore update failed");
  }

  // Create .env.local template
  if (createEnvLocalTemplate(repoPath, config)) {
    results.push("âœ… .env.local template created");
  } else {
    results.push("âš ï¸  .env.local creation failed");
  }

  // Create secrets manifest
  if (createSecretsManifestTemplate(repoPath)) {
    results.push("âœ… secrets-manifest.json created");
  } else {
    results.push("âš ï¸  secrets manifest creation failed");
  }

  return {
    repo: config.repoName,
    status: "success",
    message: results.join(" | "),
    secretsCount: Object.keys(config).filter(k => (config as unknown as Record<string, unknown>)[k]).length,
  };
}

/**
 * Main execution
 */
async function main() {
  console.log(`ðŸ“ Repository Root: ${REPOS_ROOT}\n`);

  const setupResults: SetupResult[] = [];

  for (const repo of REPOS) {
    const repoPath = path.join(REPOS_ROOT, repo);
    console.log(`Processing: ${repo}...`);
    
    const result = setupRepository(repoPath);
    setupResults.push(result);
    
    console.log(`  ${result.message}`);
    if (result.status === "failed") {
      console.log(`  âŒ Error: ${result.message}`);
    }
    console.log();
  }

  // Summary
  console.log("ðŸ“Š SETUP SUMMARY");
  console.log("================================================");
  console.log(`Total repositories: ${setupResults.length}`);
  console.log(`Successful: ${setupResults.filter(r => r.status === "success").length}`);
  console.log(`Failed: ${setupResults.filter(r => r.status === "failed").length}`);
  console.log();

  console.log("ðŸš€ NEXT STEPS:");
  console.log("1. Edit .env.local in each repository with your actual secrets");
  console.log("2. Run: npm run sync:secrets:push (to push to GitHub)");
  console.log("3. Verify: npm run sync:secrets:mobile my-device");
  console.log("4. Start: npm run api:mobile (to start mobile API)");
  console.log();

  console.log("ðŸ“‹ WHAT WAS CREATED:");
  console.log("  â€¢ .gitignore (comprehensive secret protection)");
  console.log("  â€¢ .env.local (template with encryption keys)");
  console.log("  â€¢ secrets-manifest.json (audit & documentation)");
  console.log();

  console.log("ðŸ”’ SECURITY CHECKLIST:");
  console.log("  â˜ Review .env.local values");
  console.log("  â˜ Replace template values with real credentials");
  console.log("  â˜ Never commit .env.local files");
  console.log("  â˜ Verify .gitignore is in root of each repo");
  console.log("  â˜ Run git check-ignore .env.local");
  console.log("  â˜ Push secrets to GitHub via sync:secrets:push");
  console.log();
}

main().catch(err => {
  console.error("âŒ Setup failed:", err);
  process.exit(1);
});
